# modules

Стандартного способа организации функций в пространствах имён и динамической загрузки кода в JavaScript долгое время не существовало.  
Node.js стал одним из лидеров в этой области с процветающей экосистемой модулей, использующих соглашение CommonJS.  
На стороне браузера существовал API AMD (Asynchronous Module Definition), используемый RequireJS.  
Но ни один из этих подходов не был настоящим стандартом, что приводило к бесконечным спорам о том, какой лучше.

**ES2015** стремится создать синтаксис, объединяющий лучшее из обоих миров, не заботясь об особенностях реализации.  
Комитет Ecma TC39 (отвечающий за развитие ES2015 и спецификацию языка) хотел создать удобный синтаксис (сильная сторона CommonJS),  
поддерживающий асинхронную загрузку (как в AMD), а также возможности статического анализа кода и поддержку циклических зависимостей.  
Новый синтаксис управляет тем, как вы экспортируете и импортируете вещи из модулей и в них.

Это особенно важно в **Angular**, так как практически всё определяется в модулях, которые необходимо импортировать, когда вы хотите их использовать.  
Допустим, я хочу предоставить функцию для ставки на определённого пони в гонке и функцию для запуска гонки.

**В races-service.js:**

```javascript
export function bet(race, pony) {
  // ...
}
export function start(race) {
  // ...
}
```

Как видите, всё довольно просто: новое ключевое слово `export` делает свою работу и экспортирует две функции.

Теперь предположим, что одному из компонентов нашего приложения нужно вызвать эти функции.

**В другом файле:**

```javascript
import { bet, start } from './races-service';
// позже
bet(race, pony1);
start(race);
```

Это называется **именованным экспортом**.  
Мы импортируем две функции и должны указать имя файла, содержащего эти функции — здесь это `'races-service'`.  
Конечно, можно импортировать только один метод, если он нужен, и даже дать ему псевдоним:

```javascript
import { start as startRace } from './races-service';
// позже
startRace(race);
```

А если вы хотите использовать все экспортированные символы (функции, константы, классы и т.д.) из модуля, вы можете использовать символ `*`:

```javascript
import * as racesService from './races-service';
// позже
racesService.bet(race, pony1);
racesService.start(race);
```

Как и в других языках, используйте `*` осторожно, только если вам действительно нужны все или большинство функций.  
Поскольку это будет анализироваться нашими IDE, мы скоро увидим автоимпорт, который избавит нас от забот по правильному импорту.

Если ваш модуль экспортирует только одну функцию, значение или класс, вам не нужно использовать именованный экспорт, и вы можете использовать ключевое слово **default**.  
Оно отлично работает, например, для классов:

```javascript
// pony.js
export default class Pony {}
// races-service.js
import Pony from './pony';
```

Обратите внимание на отсутствие фигурных скобок при импорте по умолчанию.  
Вы можете импортировать его с любым псевдонимом, но для согласованности лучше использовать имя модуля (кроме случаев, когда у вас несколько модулей с одинаковым именем, тогда можно выбрать другой псевдоним).  
И, конечно, вы можете смешивать экспорт по умолчанию с именованными, но, очевидно, только один `default` на модуль.

В Angular вы будете часто использовать такие импорты. Каждый компонент и сервис будет классом, как правило, изолированным в своём файле и экспортируемым, а затем импортируемым при необходимости в других компонентах.
